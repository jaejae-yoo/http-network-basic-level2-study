# 2장. 간단한 프로토콜 HTTP

## 클라이언트와 서버
HTTP 프로토콜에서는 반드시 한 쪽은 클라이언트, 다른 한 쪽은 서버의 역할을 담당함
- 클라이언트
    - 텍스트와 이미지 등과 같은 리소스를 필요하다고 요구하는 쪽
    - `Request` 가 송신됨
    - 반드시 클라이언트측으로부터 통신이 시작됨
- 서버
    - 리소스를 제공하는 쪽
    - Request 처리에 대한 `Response` 를 송신


## 무상태(stateless) 프로토콜
- Request, Response 를 교환하는 동안 상태를 관리하지 않음
- 많은 데이터를 매우 빠르고 확실하게 처리하는 범위성을 확보하기 위함
- 로그인 상태같이 유지할 필요가 있다면 **쿠키**를 사용

## Request URI 로 리소스 식별
- HTTP 는 URI를 사용해 인터넷 상의 리소스를 지정함
- URI 를 통해 인터넷 상의 어떤 장소에 있는 리소스도 호출할 수 있음
- 클라이언트는 리소스를 호출할 떄 Request 안에 Request URI 라고 불리는 형식으로 URI 를 포함해야 함

## URI 지정 방법
1. 모든 URI 를 리퀘스트 URI 에 포함
```
POST http://localhost:53750/lines HTTP/1.1
```
2. Host 헤더 필드에 네트워크 로케이션 포함
```
POST /lines HTTP/1.1
host: localhost:53750
```
- 특정 리소스가 아닌 서버 자신에게 Request 송신하는 경우
    - Request URI 에 [*] 을 지정
    - `OPTIONS * HTTP/1.1` : HTTP 서버가 지원하고 있는 메서드를 묻는 경우

## HTTP 메소드
클라이언트가 웹서버에게 요청하는 목적 및 그 종류를 알리는 수단
- 요청 메소드의 위치 : HTTP 요청 메세지의 첫째줄
    - `POST /lines HTTP/1.1`

### HTTP 메소드 속성
#### 안전(Safe Methods)
- 계속해서 메소드를 호출해도 리소스를 변경하지 않는다는 의미
- 주요 메소드중에는 GET 메소드가 안전하다고 볼 수 있음

#### 멱등(Idempotent Methods)
- 메소드를 계속 호출해도 결과가 똑같음
- GET, PUT, DELETE 는 멱등하다고 볼 수 있지만, POST 나 PATCH 는 멱등하다고 볼 수 없음

#### 캐시가능(Cacheable Methods)
- 캐싱을 해서 데이터를 효율적으로 가져올 수 있음
- GET, HEAD, POST, PATCH 가 캐시가 가능하지만 실제로는 GET 과 HEAD 만 주로 캐싱이 쓰인다고 함

### GET
- URI 로 식별된 리소스 가져와~
- GET을 사용하는 요청은 오직 데이터를 받기만 함
- 같은 요청을 여러 번 하더라도 변함없이 항상 같은 응답을 받을 수 있음
- 데이터를 변경하는 연산에 사용하면 안됨

### POST
- 주로 새로운 리소스를 생성(create)할 때 사용
- 같은 POST 요청을 반복해서 했을 때 항상 같은 결과물이 나오는 것을 보장하지 않음 (멱등하지 않음)
- URL을 통해서 데이터를 받지 않고, Body 값을 통해서 받음

### PUT
- 리소스를 생성 / 업데이트하기 위해 서버로 데이터를 보내는 데 사용
- 동일한 PUT 요청을 여러 번 호출하면 항상 동일한 결과가 생성됨 (멱등함)

### DELETE
- Request URI 로 지정된 리소스의 삭제를 요구함

### HEAD : 메시지 헤더 취득
- GET 과 같은 기능이지만 메시지 바디는 돌려주지 않음
- URI 유효성, 리소스 갱신 시간을 확인하는 목적으로 사용됨

### OPTIONS : 제공하고 있는 메소드의 문의
- 대상 리소스에 대한 통신 가능 옵션을 설명(주로 CORS에서 사용)

### TRACE : 경로 조사
- 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

### CONNECT : 프록시에 터널링 요구
- 대상 자원으로 식별되는 서버에 대한 터널을 설정


## 지속 연결 (Persistent Connections)
- TCP 연결 문제를 해결하기 위해 지속 연결 방법 고안
- 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 **TCP 연결을 계속 유지함**
- 연결 / 종료 반족에 의한 오버헤드 감소 -> 서버에 대한 부하 경감
- Request / Response 가 빠르게 완료됨

## 쿠키
- 상태를 관리하지 않는 무상태 프로토콜 HTTP
- Request, Response 에 쿠키 정보를 추가해서 클라이언트의 상태를 파악함
- 서버에서 Response 로 보내진 `Set-Cookie` 헤더 필드에 의해 쿠키를 클라이언트에 보존함
- 클라이언트가 같은 서버로 Request 를 보낼 때, 자동으로 쿠키 값을 넣어서 보냄
- 서버는 클라이언트가 보낸 쿠키를 확인해 이전 상태를 확인할 수 있

### 참고
- https://kyun2da.dev/CS/http-%EB%A9%94%EC%86%8C%EB%93%9C%EC%99%80-%EC%83%81%ED%83%9C%EC%BD%94%EB%93%9C/
- https://velog.io/@yh20studio/CS-Http-Method-%EB%9E%80-GET-POST-PUT-DELETE
