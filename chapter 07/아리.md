# 웹을 안전하게 지켜주는 HTTPS

## HTTP의 약점

1) 암호화 되지 않은 평문을 전송하기 때문에 `도청` 가능

- 패킷캡처/스니퍼 : 네트워크상에 흐르고있는 패킷을 수집하여 도청
- 해결방안
    - 통신 암호화
        - SSL, TLS 등의 프로토콜을 조합함으로써 안전한 통신로를 확보
        - HTTPS : SSL을 조합한 HTTP
    - 콘텐츠 암호화
        - 콘텐츠 내용 자체를 암호화
        - 클라이언트와 서버가 암호화 및 복호화 구조를 가지고있어야 하기 때문에 브라우저, 웹 서버 등에서 이용하기 어려움

- 암호화 해도 도청 가능? 물론! 암호화 된 메시지이기 때문에 의미를 파악할 수 없을 뿐!


2) 통신 상대를 확인하지 않기 때문에 `위장` 가능

- 문제 상황
    - request를 보낸 곳이 실제 서버가 아닐수도 있다. 위장된 서버일 수 있다.
    - response를 받은 클라이언트가 request를 보낸 클라이언트가 아닐 수도 있다. 위장된 클라이언트일 수 있다.
    - 접근이 허가되지 않은 클라이언트일 수 있다.
    - 누가 request를 보낸 것인지 확인할 수 없다.
    - 의미 없는 request도 수신한다. (대량의 request를 보내 서버를 다운시키는 DoS 공격에 취약해짐)
- 해결방안
    - 증명서
        - 신뢰할 수 있는 제3의 기관에서 발급된 증명서를 이용하여 인증된 서버, 클라이언트임을 증명

3) 완전성을 증명할 수 없기 때문에 `변조` 가능

- request 혹은 response가 전송과정에서 변조되었을 수 있다. -> 중간자 공격 (Middle in the Middle attack)
- 해결방안
    - MD4나 SHA-1 등의 해시값 확인 -> 이 값까지도 변조할 수 있기 때문에 완전한 해결방안은 아님
    - HTTPS
        - 인증, 암호화, 다이제스트 기능 제공

## HTTPS (Http Secure)

- HTTP의 통신을 담당하는 부분이 SSL 혹은 TLS 프로토콜로 대체된 것! -> SSL이 TCP와 통신함
- 암호화, 증명서, 완전한 보호 등 이용가능

## HTTPS의 암호화

- 공통키와 공개키 성질을 모두 가진 하이브리드 암호 시스템 이용
- 공통키를 전달할 때에는 공개키를 사용하고, 그렇게 키가 전달되었다면 공통키 이용
- why? 공개키 암호는 공통키 암호에 비해서 처리속도가 늦기 때문

## 공통키 암호화

- 암호 알고리즘이 공개된 채로 키를 통해 암호화/복호화를 진행
- 키가 노출되는 순간 끝장..!
- 암호화 복호화에 같은 키를 사용하기 위해서는 키를 전송해야한다. -> 이때 탈취당한다면? 끝장..!

## 공개키 암호화

- 공개키(public key)와 비밀키(private key) 
- 공개키를 이용하여 암호화 / 비밀키를 이용하여 복호화 
  - -> 데이터를 보호해야할 때 이용
  - ex) 클라이언트에서 공개키로 암호화한 비밀번호를 서버가 복호화하여 확인
- 비밀키를 이용하여 암호화 / 공개키를 이용하여 복호화 
  - -> 인증이 필요할 때 이용
  - ex) 서버가 암호화한 공통키를 클라이언트가 복호화하여 이용
- 공개키만을 이용하여 암호/복호화를 진행하는 것은 매우 어렵고, 비밀키가 노출될 일이 없기 때문에 더욱 안전하다.

## 공개키가 변조되지 않았음을 어떻게 증명할까?

#### 인증기관(CA)과 공개키 증명서 이용!

1) 서버가 인증기관에게 공개키 제출
2) 인증기관에서 공개키에 디지털 서명을 하여 새로운 공개키 생성, 이를 담은 공개키 인증서 발급
3) 서버에서 해당 인증서를 공개키 암호화를 이용하여 클라이언트에게 전송

인증기관의 공개키가 변조되지 않았음을 어떻게 증명할까? <br>
-> 대부분의 브라우저가 주요 인증기관의 공개키를 사전에 내장

## EVLLS 증명서

: 세계 표준의 인정 가이드라인에 의해 발행되는 증명서로써 실제로 증명된 기업임을 보장 <br>
대부분의 사용자는 이를 인식하고 확인하지 않기 때문에 효과가 있는지는 의문

## 클라이언트 증명서

: 서버가 통신하고 있는 상대가 증명된 클라이언트임을 보장

- 문제점
    - 사용자가 클라이언트 증명서를 설치해야한다.
    - 유료이기 때문에 클라이언트 수 만큼의 비용이 발생한다.
    - 클라이언트의 실재를 증명할 뿐, 사용자의 존재 유무를 증명하지는 않는다. ( 해당 인증서가 설치된 컴퓨터라면 누구나 이용가능 )
- 사용처
    - 은행 인터넷 뱅킹 : 특정 단말기만 접속을 허용하도록 함

## HTTPS 통신 과정

1) 클라이언트 - 메시지를 송신하며 SSL 통신 시작 : 클라이언트가 제공하는 SSL버전, 암호 스위트 등 포함
2) 서버 - SSL 통신이 가능하다면 응답 : 클라이언트에게서 받은 SSL버전, 암호 스위트 등 포함
3) 서버 - 공개키 증명서가 포함된 Certificate 메시지 송신
4) 서버 - 최초의 SSL 네고시에이션 부분이 끝났음을 통지
5) 클라이언트 - Client Key Exchange 메시지로 응답 : 통신을 암호화하는데 사용하는 Pre-Master secret이 공개키로 암호화되어 포함
6) 클라이언트 - Change Cipher Spec 메시지를 송신 : 이 메시지 이후의 송신은 암호키를 이용함을 나타냄
7) 클라이언트 - Finished 송신 : 접속 전체의 체크값 포함
8) 서버 - Change Cipher Spec 메시지를 송신
9) 서버 - Finished 송신
10) 접속 확립! 클라이언트 - request 송신
11) 서버 - response 송신
12) 클라이언트 - close_notify 메시지를 송신함으로써 접속을 끊고 TCP FIN 메시지를 보내 TCP 통신 종료

덧붙여, 애플리케이션 계층의 데이터를 송신할 때에는 MAC 이라 불리는 다이제스트 이용 <br>
-> 변조를 감지하여 완전성 보호

## SSL과 TLS

- TLS는 SSL을 기반으로 한 프로토콜이기 때문에 이들을 통칭해서 SSL이라 부르기도 한다.
- SSL3.0과 TLS1.0이 주로 이용된다.
- SSL1.0과 SSL2.0은 문제가 발견되어 많은 브라우저에서 무효화된다.

## SSL은 느리다
- 암호화/복호화 등을 위해 리소스를 다량으로 소비하기 때문에 처리가 느리다.
- TCP 접속, HTTP request/response 이외의 SSL에 필요한 통신이 추가되기 때문에 통신이 느리다.
- SSL 엑셀레이터
  - SSL을 처리하기 위한 전용 하드웨어
  - 소프트웨어로 처리할 때 보다 빠르다!


