# 누가 액세스하고 있는지를 확인하는 인증
특정 인물에게만 페이지를 보여줄 때 인증 기능이 필요

## BASIC 인증
- HTTP/1.0에 구현된 인증 방식으로 현재에도 일부 사용됨
- 웹 서버와 대응하고 있는 클라이언트 사이에서 이뤄지는 방식 
- Base64 인코딩을 사용하나 암호화가 아니므로 아무 조건 없이 복호화 가능
- 인증을 한번 하면, 일반 브러우저에서는 로그아웃할 수 없음

**인증 수순**
1. 리퀘스트가 오면 서버에서 상태코드 `401 Authorization Required`와 함께 인증 방식(BASIC)과 Request-URI의 보호 공간을 식별하기 위한 문자열을 `WWW-Authenticate`헤더 필드에 포함하여 리스폰스 반환
2. 401을 받은 클라이언트에서 유저 ID와 패스워드를 인코딩한 문자열을 `Authorization` 헤더 필드에 포함하여 서버에 송신
   - 송신하는 문자열은 `:`으로 연결한 문장을 Base64 형식으로 인코딩
   - ex) ID와 비밀번호가 각각 pepper, pepper 경우: `pepper:pepper` ➡️ `cGVwcGVyOnBlcHBlcg==`
3. 수신한 서버는 인증 정보가 정확한지 판단. 정확한 경우 `Request-URI` 리소스를 포함한 리스폰스를 반환

## DIGEST 인증
- BASIC 인증을 보안하며 HTTP/1.0에 소개된 인증 방식
- 챌린지 리스폰스 방식 사용
  - 최초에 상대방에게 인증 요구를 보내고 상대방 측에서 받은 챌린지 코드를 사용해서 리스폰스 코드를 계산한다. 계산된 값을 상대에게 송신하여 인증하는 방식이다.
  - 패스워드가 누출된 가능성이 BASIC보다 줄어든다.
- 도청 방지는 가능하나, 위장 방지 기능은 제공하지 않음
- 많이 사용되는 방식은 아님

**인증 수순**
1. 리퀘스트가 오면 서버는 상태코드 `401 Authorization Required`와 챌린지 코드를 `WWW-Authenticate`헤더 필드에 포함하여 리스폰스 반환
  - 헤더 필드에는 반드시 `realm`와 `nonce` 두가지를 포함
2. 수신받은 클라이언트에서는 `username`, `realm`, `nonce`, `uri`, `response`를 `Authorization` 헤더 필드에 포함하여 서버에 송신
  - `realm`와 `nonce`는 서버에서 받은 것을 사용
3. 리퀘스트를 받은 서버는 인증 겅보가 정확한지 판단. 정확한 경우 `Request-URI` 리소스를 포함한 리스폰스를 반환. `Authentication-Info`헤더 필드에 성공한 인증에 대한 정보 추가 가능


## SSL 클라이언트 인증
- HTTPS 인증서를 사용하는 인증 방식
- 사전에 등록된 클라이언트에서의 엑세스인지 아닌지 확인 가능
- 주로 단독으로 사용하기 보단, 다른 폼 베이스 인증과 합쳐져 2-factor 인증으로 이용
  - 2-factor 인증: 패스워드 한 개의 요소만이 아닌 이용자가 가진 다른 정보를 병용하여 인증하는 방식
- 사용되는 클라이언트 증명서를 이용하기 위해서는 상당한 비용이 발생함

**인증 수순**
0. 사전에 클라이언트에 클라이언트 증명서를 배포하고 설치해야함
1. 리퀘스트가 오면 서버는 클라이언트 증명서를 요구하는 `Certificate Request` 메세지 송신
2. 유저는 송신하는 클라이언트 증명서를 선택. 클라이언트는 `Client Certificate` 메세지 송신
3. 서버는 클라이언트 증명서를 검증. 정확한 경우 클라이언트의 공개키 취득. 이후 HTTPS에 의한 암호를 개시

## 폼 베이스 인증
- 사양이 정의된 인증 방식 ❌
- 클라이언트가 서버 상의 웹 애플리케이션에 자격 정보를 송신하여 검증 결과에 따라 인증을 하는 방식
  - 다양한 인증 방식이 존재
  - 주로 세션 관리를 위해 쿠키를 사용하는 방법이 사용됨
  - 일반적으로 패스워드를 `salt`라는 부가 정보를 사용해서 해시 알고리즘으로 계산한 값을 저장
- 웹 애플리케이션에서 주로 사용되는 인증 방식
  - 안전한 방법으로 구현된 높은 보안 등급을 유지할 수도 있으나, 문제 있는 구조를 갖는 웹 사이트도 있음

**인증 수순**
1. 리퀘스트가 올 때 엔티티 바디에 자격 정보를 저장. (HTTPS 통신)
2. 서버 측은 유저를 식별하기 위한 세션 ID 발행. 클라이언트에서 수신한 자격 정보를 검증하여 인증하고, 인증 상태를 세션 ID와 연관지어 서버에 기록. 클라이언트로 송신할 때는 `Set-Cookie`헤더 필드에 세션 ID를 저장해서 리스폰스를 반환
   - 도난 가능성이 있는 세션 ID는 어려운 문자열을 사용하고, 유효 기간을 관리해야함
   - 크로스 사이트 스크립팅 등의 취약성이 존재한 경우, 피해를 줄이기 위해 쿠키에 `httponly` 속성 부여
3. 클라이언트는 받은 세션 ID를 쿠키로 저장. 이후 리퀘스트를 보낼 때는 브라우저가 자동으로 쿠키를 송출

