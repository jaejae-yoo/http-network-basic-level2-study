# 누가 액세스하고 있는지를 확인하는 인증

## BASIC 인증

1) 클라이언트 - request 송신
2) 서버 - response에 401을 통해 인증이 필요함을 전달
    - request-uri의 보호공간을 식별하기 위한 문자열(realm)을 WWW-Authenticate 헤더필드에 포함
3) 클라이언트 - id:비밀번호 를 Base64로 인코딩 한 값을 Authorization 헤더필드에 포함하여 송신
4) 서버 - 송신된 값의 정확성 여부 판단, 정확하다면 request-uri 리소스를 포함한 리스폰스 반환

- 문제점!
    - Base64는 암호화가 아니기 때문에 정보 노출
    - 브라우저에서 로그아웃 불가능
    - 사용상의 문제 존재
    - 웹 사이트에서 요구되는 보안등급에 미치지 못함

- 결론 : 잘 쓰이지 않음

## DIGEST 인증

: 챌린지 리스폰스 방식을 통해 정보 노출될 일 없음

1) 클라이언트 - request 송신
2) 서버 - response에 401을 통해 인증이 필요함을 전달
    - request-uri의 보호공간을 식별하기 위한 문자열(realm)과 인증에 필요한 챌린지 코드(nonce)를 WWW-Authenticate 헤더필드에 포함
    - nonce : 401 response를 보낼때마다 생성되는 유일한 문자열
3) 클라이언트 - 인증에 필요한 정보를 Authorization 헤더필드에 포함하여 송신
    - username, realm, nonce, uri, response 는 필수 포함
    - username : 지정된 realm에서 인증 가능한 사용자 이름
    - realm, nonce는 서버에서 받은 것을 사용
    - uri : 프록시에 의해 request uri가 변경될 수도 있기 때문에 한번 더 명시
    - response : 패스워드 문자열을 MD5로 계산
4) 서버 - 올바른 인증정보인지 확인, 확인되었다면 request uri를 포함한 리스폰스를 반환
    - Authentication-info 헤더필드에 성공한 인증에 대한 몇가지 정보를 추가하기도 함
      <br>

- BASIC에 비해 보안 등급이 높기는 하지만 HTTPS의 클라이언트 인증 등에 비하면 낮음
- 패스워드 도청은 방지하지만 위장은 방지하지 못함
- 결론 : 잘 쓰이지 않음

## SSL 클라이언트 인증

1) 사전에 클라이언트에 클라이언트 증명서를 배포하고 설치
2) 클라이언트 - request 송신
3) 서버 - 증명서를 요구하는 Certificate Request 라는 메시지 송신
4) 클라이언트 - 증명서 송신
5) 서버 - 수신된 증명서를 검증하여 HTTPS 개시

- 단독으로 사용되는 경우는 거의 없으며 폼베이스 인증과 함께 2-factor 인증의 하나로써 이용된다.
- 2-factor인증이란? 한개의 요소가 아닌 여러개의 요소를 병용하여 인증을 하는 방식
    - ex) SSL 클라이언트 인증을 통해 클라이언트의 컴퓨터를 인증하고, 비밀번호를 통해 사용자 본인임을 한번 더 인증
- 증명서가 필요하기 때문에 비용도 필요!

## 폼 베이스 인증

: 클라이언트가 서버에게 자격정보(Credential)를 송신하여 인증 -> HTTP 프로토콜로써 사양이 정의된 것은 아님!

- BASIC과 DIGEST는 사용상/보안상의 문제로 잘 사용되지 않고, SSL은 비용이 발생하므로 폼베이스를 가장 많이 사용
- 공통사양이 정해져있지 않기 때문에 웹사이트별로 다르게 구현
- 쿠키와 세션이 대표적인 예
    1) 클라이언트 - 자격정보를 포함한 request 송신 ( 대부분 POST, HTTPS 사용 )
    2) 서버 - 세션ID발행, response의 Set-Cookie 헤더필드에 세션ID 담아 송신
    3) 클라이언트 - 수신받은 세션ID 쿠키에 저장. 앞으로 request에는 브라우저가 자동으로 쿠키를 송출
