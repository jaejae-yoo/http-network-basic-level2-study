## 인증
- 서버에서 클라이언트의 정체를 확인할 필요가 있는 경우가 있다. 
- 패스워드/원타임 토큰/보안카드/증명서 등의 다양한 본인 인증 정보를 통해 인증한다. 
- HTTP/1.1 에서는 `BASIC 인증`, `DIGEST 인증`, `SSL 클라이언트 인증`, `폼 베이스 인증` 등의 인증 방식을 활용한다.

### BASIC 인증
- HTTP/1.0 에 구현된 인증 방식
- 웹 서버 <-> 클라이언트 사이에서 이뤄지는 인증 방식
- Base64 인코딩 방식은 암호화가 아니기 때문에, 도청 가능성이 존재
- 일반 브라우저에서는 로그아웃할 수 없음

### BASIC 인증 수순
1. 클라이언트가 리퀘스트 송신
2. 리퀘스트에서 요구한 리소스가 BASIC 인증 대상인 경우, 서버는 `401 Unauthorized` 상태 코드와 함께 `WWW-Authenticate` 헤더에 인증 방식과 식별 문자열을 넣어서 응답한다.
3. 클라이언트는 인증에 필요한 정보를 `Base64` 형식으로 인코딩하여 `Authorization` 헤더에 담아 전송한다.
4. 서버는 인증에 성공하면 `200 ok` 코드와 함께 요구된 리소스를 반환하고, 실패하면 다시 `401` 코드를 반환한다.  


### DIGEST 인증
- `챌린지 리스폰스` : 최초에 상대방에게 인증 요구를 보낸 후, 상대방에게 받은 챌린지 코드를 사용해서 리스폰스 코드를 계산하고, 이를 다시 상대방에게 송신하여 인증하는 방식
- DIGEST 인증 방식은 챌린지 리스폰스 방식을 사용하여 BASIC 인증 방식에 비해 패스워드 누출 가능성이 낮다. 
- BASIC 보다는 낫지만, 마찬가지로 보안성이 좋지 않다.

### DIGEST 인증 수순
1. 클라이언트가 리퀘스트 송신
2. 리퀘스트에서 요구한 리소스가 DIGEST 인증 대상인 경우, 서버는 `401 Unauthorized` 상태 코드와 함께 `WWW-Authenticate` 헤더에 인증 방식과 식별 문자열, 챌린지 코드를 넣어서 응답한다.
3. 클라이언트는 인증에 필요한 정보를 `Authorization` 헤더에 담아 전송한다.
4. 서버는 인증에 성공하면 `200 ok` 코드와 함께 요구된 리소스를 반환하고, 실패하면 다시 `401` 코드를 반환한다.  

### SSL 클라이언트 인증
- HTTPS의 클라이언트 인증서를 활용한 인증 방식
- 사전에 클라이언트에 클라이언트 증명서를 설치해야 한다.
- 단독으로 사용되기 보다는, 주로 폼 베이스 인증 방식과 함께 `2-factor 인증`의 하나로 이용된다.
- 클라이언트 인증서가 필요해서 비용이 요구된다.  

### SSL 클라이언트 인증 수순
1. 클라이언트가 리퀘스트 송신
2. 리퀘스트에서 요구한 리소스가 인증 대상인 경우, 서버는 `Certificate Request` 메시지를 송신한다.
3. 유저는 송신할 클라이언트 증명서를 선택하고, 클라이언트는 `Client Certificate` 메시지를 송신한다. 
4. 서버는 클라이언트 증명서를 검증한 뒤, 클라이언트의 공개키를 취득하여 암호화를 개시한다. 


### 폼 베이스 인증
- 클라이언트가 서버상의 웹 어플리케이션에 자격 정보를 송신하여 인증하는 방식
- HTTP에 정의되어 있는 인증 방식은 아님
- 웹 어플리케이션에 따라 다양한 인증 방식
- 대부분 사전 등록된 아이디나 패스워드 등을 입력하여 검증한다.
- 현재 주류 인증 방식

### 세션 관리와 쿠키에 의한 폼 베이스 인증 수순
1. 클라이언트가 서버에 인증에 필요한 자격 정보를 담은 리퀘스트를 송신한다. (HTTPS 사용)
2. 서버는 자격 정보를 검증한 뒤, 유저 식별을 위한 `세션 ID` 를 발행하고, 이를 쿠키에 담아 송신한다. 
3. 클라이언트는 수신한 세션 ID를 쿠키로 저장한다. 



